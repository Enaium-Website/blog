<!doctype html><html><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>JDK22新特性Class-File API尝鲜</title>
<link rel=stylesheet href=/css/bootstrap.min.css></head><body class="d-flex flex-column justify-content-between min-vh-100"><nav class="navbar navbar-expand-lg bg-light"><div class=container-fluid><a class=navbar-brand href=/><img src=https://simpleicons.org/icons/github.svg alt=Logo width=30 height=24 class="d-inline-block align-text-top">
Enaium's Blog
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link aria-current=page href=https://blog.enaium.cn/contact/>Contact</a></li><li class=nav-item><a class=nav-link aria-current=page href=https://blog.enaium.cn/about/>About</a></li></ul></div></div></nav><div style=flex:1><div class=container><div class=card><div class=card-header>JDK22新特性Class-File API尝鲜</div><div class=card-body><div class=card-text><h2 id=前言>前言</h2><p>到目前为止<code>JDK22</code>已经<code>Final Release Candidate</code>了，不出意外的话，这个就是最终<code>General Availability</code>版本了，在本次更新有一个新的的特性也就是，<code>Class-File API</code>，不过还是在预览版中，不过我们可以尝鲜一下，也就是在未来的版本中可能会被删除或者修改，大家在之前可能使用过<code>ASM</code>等第三方库，但现在<code>JDK</code>是每6个月就会发布一个新的版本，第三方库可能会更新不及时，所以<code>JDK</code>内置了一个<code>Class-File API</code>，这样就可以更好的支持<code>Java</code>的新特性。</p><h2 id=安装>安装</h2><p>我们先需要在<a href=https://jdk.java.net/22/>jdk.java.net</a>JDK22，之后再<code>IntelliJ IDEA</code>中开启<code>22(Preview)</code>，之后就可以使用<code>Class-File API</code>了。</p><h2 id=使用>使用</h2><h3 id=读取类信息>读取类信息</h3><p>我们首先是读取一个<code>class</code>文件，也就是读取它的类信息，既然是读取类，我们就写一个类之后再编译。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Enaium&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>render</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>之后我们在<code>IntelliJ IDEA</code>中编译一下，然后我们就可以读取这个<code>class</code>文件了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    ClassFile.<span style=color:#a6e22e>of</span>().<span style=color:#a6e22e>parse</span>(Path.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;out/production/untitled1/Test.class&#34;</span>));
</span></span><span style=display:flex><span>    ClassFile.<span style=color:#a6e22e>of</span>().<span style=color:#a6e22e>parse</span>(Files.<span style=color:#a6e22e>readAllBytes</span>(Path.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;out/production/untitled1/Test.class&#34;</span>)));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以看到<code>ClassFile</code>有一个<code>of</code>方法，这个方法返回一个<code>ClassFile</code>对象，然后我们可以调用<code>parse</code>方法解析<code>class</code>文件，这里可以使用两种方法，一种是传入<code>Path</code>对象，一种是传入<code>byte</code>数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ClassModel parse <span style=color:#f92672>=</span> ClassFile.<span style=color:#a6e22e>of</span>().<span style=color:#a6e22e>parse</span>(Path.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;out/production/untitled1/Test.class&#34;</span>));
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(parse.<span style=color:#a6e22e>majorVersion</span>());
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(parse.<span style=color:#a6e22e>superclass</span>().<span style=color:#a6e22e>get</span>().<span style=color:#a6e22e>name</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (PoolEntry poolEntry : parse.<span style=color:#a6e22e>constantPool</span>()) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(STR.<span style=color:#e6db74>&#34;  \{poolEntry.toString()}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以看到<code>ClassFile</code>有一个<code>parse</code>方法，这个方法返回一个<code>ClassModel</code>对象，然后我们可以调用<code>majorVersion</code>方法获取<code>class</code>文件的版本，<code>superclass</code>方法获取父类，<code>constantPool</code>方法获取常量池。</p><p>其中<code>PoolEntry</code>比较特殊，它是一个接口，所以我直接调用<code>toString</code>方法，这个方法返回一个<code>String</code>对象，这个对象就是常量池的内容，我们进入到<code>JDK</code>源码中，获取它有哪些实现类，<code>ClassEntry</code>、<code>FieldRefEntry</code>、<code>MethodRefEntry</code>等等。</p><h3 id=读取字段信息>读取字段信息</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ClassModel parse <span style=color:#f92672>=</span> ClassFile.<span style=color:#a6e22e>of</span>().<span style=color:#a6e22e>parse</span>(Path.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;out/production/untitled1/Test.class&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (FieldModel field : parse.<span style=color:#a6e22e>fields</span>()) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(STR.<span style=color:#e6db74>&#34;\{field.flags().flags()} \{field.fieldName()}: \{field.fieldType()} | \{field.fieldTypeSymbol().packageName()}.\{field.fieldTypeSymbol().displayName()}&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们调用<code>fields</code>可以获取这个类中的所有字段，然后我们可以调用<code>flags</code>方法获取字段的修饰符，<code>fieldName</code>方法获取字段的名字，<code>fieldType</code>方法获取字段的类型，<code>fieldTypeSymbol</code>方法获取字段的类型的符号。</p><h3 id=读取方法信息>读取方法信息</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ClassModel parse <span style=color:#f92672>=</span> ClassFile.<span style=color:#a6e22e>of</span>().<span style=color:#a6e22e>parse</span>(Path.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;out/production/untitled1/Test.class&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (MethodModel method : parse.<span style=color:#a6e22e>methods</span>()) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(STR.<span style=color:#e6db74>&#34;\{method.flags().flags()} \{method.methodName()}\{method.methodType()}&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (CodeElement codeElement : method.<span style=color:#a6e22e>code</span>().<span style=color:#a6e22e>get</span>()) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(STR.<span style=color:#e6db74>&#34;  \{codeElement}&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>和读取字段不同的是，可以使用<code>code</code>方法获取方法的指令，类似于<code>ASM</code>的中的<code>Instruction</code>。</p><h3 id=创建类信息>创建类信息</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Enaium&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> build <span style=color:#f92672>=</span> ClassFile.<span style=color:#a6e22e>of</span>().<span style=color:#a6e22e>build</span>(ClassDesc.<span style=color:#a6e22e>of</span>(name), classBuilder <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    Files.<span style=color:#a6e22e>write</span>(Path.<span style=color:#a6e22e>of</span>(STR.<span style=color:#e6db74>&#34;\{name}.class&#34;</span>), build);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里使用<code>ClassFile</code>中的<code>build</code>方法构建一个<code>class</code>文件，这个方法传入一个类信息，一个<code>ClassBuilder</code>的消费者，我们这里只是创建一个空的<code>class</code>文件，之后我们将返回的<code>byte</code>数组写入到文件中，之后我们使用<code>IntelliJ IDEA</code>打开这个<code>class</code>文件，我们可以看到这个<code>class</code>文件是一个空的<code>class</code>文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Source code recreated from a .class file by IntelliJ IDEA</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// (powered by FernFlower decompiler)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Enaium</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=添加字段信息>添加字段信息</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>classBuilder.<span style=color:#a6e22e>withField</span>(<span style=color:#e6db74>&#34;name&#34;</span>, ClassDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;Ljava/lang/String;&#34;</span>), ClassFile.<span style=color:#a6e22e>ACC_PUBLIC</span>);
</span></span></code></pre></div><p>这里使用<code>withField</code>方法添加一个字段，这个方法传入字段的名字，字段的类型，字段的修饰符。</p><h3 id=添加方法信息>添加方法信息</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>classBuilder.<span style=color:#a6e22e>withMethod</span>(<span style=color:#e6db74>&#34;&lt;init&gt;&#34;</span>, MethodTypeDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;()V&#34;</span>), ClassFile.<span style=color:#a6e22e>ACC_PUBLIC</span>, methodBuilder <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>这里使用<code>withMethod</code>方法添加一个方法，这个方法传入方法的名字，方法的类型，方法的修饰符，一个<code>MethodBuilder</code>的消费者，我们这里只是创建一个空的方法。</p><h3 id=添加代码信息>添加代码信息</h3><p>这里我们为刚才创建好的字段添加一个值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>methodBuilder.<span style=color:#a6e22e>withCode</span>(codeBuilder <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    codeBuilder.<span style=color:#a6e22e>aload</span>(codeBuilder.<span style=color:#a6e22e>receiverSlot</span>());
</span></span><span style=display:flex><span>    codeBuilder.<span style=color:#a6e22e>invokespecial</span>(ClassDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;Ljava/lang/Object;&#34;</span>), <span style=color:#e6db74>&#34;&lt;init&gt;&#34;</span>, MethodTypeDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;()V&#34;</span>));
</span></span><span style=display:flex><span>    codeBuilder.<span style=color:#a6e22e>aload</span>(codeBuilder.<span style=color:#a6e22e>receiverSlot</span>());
</span></span><span style=display:flex><span>    codeBuilder.<span style=color:#a6e22e>ldc</span>(<span style=color:#e6db74>&#34;Enaium&#34;</span>);
</span></span><span style=display:flex><span>    codeBuilder.<span style=color:#a6e22e>putfield</span>(ClassDesc.<span style=color:#a6e22e>of</span>(name), <span style=color:#e6db74>&#34;name&#34;</span>, ClassDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;Ljava/lang/String;&#34;</span>));
</span></span><span style=display:flex><span>    codeBuilder.<span style=color:#a6e22e>return_</span>();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>这里使用<code>withCode</code>方法添加代码，这个方法传入一个<code>CodeBuilder</code>的消费者，这里我们使用<code>aload</code>方法加载<code>this</code>，<code>invokespecial</code>方法调用父类的构造方法，<code>putfield</code>方法设置字段的值，<code>return_</code>方法返回。</p><p>现在我们可以创建一个方法用来获取刚才创建好的字段。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>classBuilder.<span style=color:#a6e22e>withMethod</span>(<span style=color:#e6db74>&#34;getName&#34;</span>, MethodTypeDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;()Ljava/lang/String;&#34;</span>), ClassFile.<span style=color:#a6e22e>ACC_PUBLIC</span>, methodBuilder <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    methodBuilder.<span style=color:#a6e22e>withCode</span>(codeBuilder <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        codeBuilder.<span style=color:#a6e22e>aload</span>(codeBuilder.<span style=color:#a6e22e>receiverSlot</span>());
</span></span><span style=display:flex><span>        codeBuilder.<span style=color:#a6e22e>getfield</span>(ClassDesc.<span style=color:#a6e22e>of</span>(name), <span style=color:#e6db74>&#34;name&#34;</span>, ClassDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;Ljava/lang/String;&#34;</span>));
</span></span><span style=display:flex><span>        codeBuilder.<span style=color:#a6e22e>areturn</span>();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>这里使用<code>withCode</code>方法添加代码，这个方法传入一个<code>CodeBuilder</code>的消费者，这里我们使用<code>aload</code>方法加载<code>this</code>，<code>getfield</code>方法获取字段，<code>areturn</code>方法返回，这里返回的是一个对象，所以和刚才的<code>return_</code>不一样。</p><p>之后我也可以添加一个方法来设置刚才创建好的字段。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>classBuilder.<span style=color:#a6e22e>withMethod</span>(<span style=color:#e6db74>&#34;setName&#34;</span>, MethodTypeDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;(Ljava/lang/String;)V&#34;</span>), ClassFile.<span style=color:#a6e22e>ACC_PUBLIC</span>, methodBuilder <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    methodBuilder.<span style=color:#a6e22e>withCode</span>(codeBuilder <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        codeBuilder.<span style=color:#a6e22e>aload</span>(codeBuilder.<span style=color:#a6e22e>receiverSlot</span>());
</span></span><span style=display:flex><span>        codeBuilder.<span style=color:#a6e22e>aload</span>(codeBuilder.<span style=color:#a6e22e>parameterSlot</span>(0));
</span></span><span style=display:flex><span>        codeBuilder.<span style=color:#a6e22e>putfield</span>(ClassDesc.<span style=color:#a6e22e>of</span>(name), <span style=color:#e6db74>&#34;name&#34;</span>, ClassDesc.<span style=color:#a6e22e>ofDescriptor</span>(<span style=color:#e6db74>&#34;Ljava/lang/String;&#34;</span>));
</span></span><span style=display:flex><span>        codeBuilder.<span style=color:#a6e22e>return_</span>();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=测试>测试</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> Object o <span style=color:#f92672>=</span> URLClassLoader.<span style=color:#a6e22e>newInstance</span>(Collections.<span style=color:#a6e22e>singleton</span>(Path.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;.&#34;</span>).<span style=color:#a6e22e>toUri</span>().<span style=color:#a6e22e>toURL</span>()).<span style=color:#a6e22e>toArray</span>(URL<span style=color:#f92672>[]</span>::<span style=color:#66d9ef>new</span>)).<span style=color:#a6e22e>loadClass</span>(name).<span style=color:#a6e22e>getConstructor</span>().<span style=color:#a6e22e>newInstance</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> Method getName <span style=color:#f92672>=</span> o.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;getName&#34;</span>);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName.<span style=color:#a6e22e>invoke</span>(o));
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> Method setName <span style=color:#f92672>=</span> o.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;setName&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>setName.<span style=color:#a6e22e>invoke</span>(o, <span style=color:#e6db74>&#34;This is enaium&#39;s class file&#34;</span>);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName.<span style=color:#a6e22e>invoke</span>(o));
</span></span></code></pre></div><p>这里我们使用<code>URLClassLoader</code>加载刚才创建好的<code>class</code>文件，之后我们就可以使用反射调用里面的方法了。</p><h2 id=总结>总结</h2><p>本篇文章简单的使用了<code>Class-File API</code>，之后我会继续深入的了解这个新特性，也会写一些关于<code>Class-File API</code>的文章。</p></div><div class="d-flex justify-content-between"><a class=text-reset href=https://blog.enaium.cn/post/2024-2-5-%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E8%AE%A9%E6%82%A8%E7%9A%84gradle%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E8%B5%B7%E9%A3%9E/>一个脚本让您的Gradle项目下载速度起飞</a></div></div></div></div></div><footer class="p-5 bg-dark text-white text-center"><div class=container><p class=lead>Copyright &copy; 2024 Enaium</p></div></footer><script src=/js/bootstrap.bundle.min.js></script></body></html>